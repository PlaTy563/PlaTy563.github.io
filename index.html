<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>かものはし家計簿</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="icon-512.png">
    <link rel="manifest" href="manifest.json">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script type="module">
        // GoogleGenerativeAIはモジュールとしてインポート
        import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";
        window.GoogleGenerativeAI = GoogleGenerativeAI;
    </script>
    <script>
        // gapiLoadedとgisLoadedはonload属性から呼び出されるため、グローバルスコープで定義
        let tokenClient, gapiInited = false, gsiInited = false, backupFileId = null;

        function gapiLoaded() {
            gapi.load('client', initializeGapiClient);
        }

        function gisLoaded() {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: '', // callback will be set dynamically
            });
            gsiInited = true;
            maybeInitAuth();
        }

        async function initializeGapiClient() {
            await gapi.client.init({ apiKey: API_KEY, discoveryDocs: [DISCOVERY_DOC] });
            gapiInited = true;
            maybeInitAuth();
        }
    </script>
    <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>
    <style>
        :root{--primary-color:#2e7d32;--primary-dark-variant:#266b2a;--primary-light-variant:#5cb85c;--background-light:#f8f8f8;--card-bg-light:#fff;--text-color-light:#333;--border-color-light:#e0e0e0}
        *,*::before,*::after{box-sizing:border-box}
        body{margin:0;font-family:'Noto Sans JP',sans-serif;padding-bottom:90px;background-color:var(--background-light);color:var(--text-color-light)}
        @media (prefers-color-scheme:dark){:root{--background-light:#121212;--card-bg-light:#1e1e1e;--text-color-light:#e0e0e0;--border-color-light:#444}}
        header{display:flex;align-items:center;padding:1rem;background-color:var(--primary-dark-variant);color:#fff;width:100%;max-width:48rem;margin:0 auto;box-shadow:0 4px 6px rgba(0,0,0,.1);border-bottom-left-radius:.75rem;border-bottom-right-radius:.75rem}
        header img{width:64px;height:64px;margin-right:1rem}
        header h1{font-size:1.75rem;font-weight:700;margin:0}
        main{display:flex;flex-direction:column;align-items:center;width:100%;max-width:48rem;margin:2rem auto;padding:0 1rem}
        section{background-color:var(--card-bg-light);padding:1.5rem;border-radius:.75rem;box-shadow:0 4px 6px rgba(0,0,0,.1);margin-bottom:1.5rem;width:100%}
        h2{font-size:1.25rem;font-weight:700;margin-top:0;margin-bottom:1rem}
        .tab-buttons{position:fixed;bottom:0;left:0;right:0;background-color:var(--primary-dark-variant);box-shadow:0 -4px 6px rgba(0,0,0,.1);display:flex;justify-content:space-around;padding:.75rem;z-index:10}
        .tab-buttons button{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:.5rem 0;border:none;background-color:transparent;color:#fff;font-size:.75rem;border-radius:.5rem;transition:background-color .2s}
        .tab-buttons button.active{background-color:var(--primary-light-variant)}
        .tab-buttons button span{font-size:1.5rem;line-height:1}
        form input,form select,form button{width:100%;padding:.75rem;border-radius:.5rem;border:1px solid var(--border-color-light);font-size:1rem;margin-bottom:.75rem}
        button{background-color:var(--primary-color);color:#fff;font-weight:700;border:none;cursor:pointer;transition:background-color .2s;border-radius:.5rem;padding:.75rem 1rem}
        button:hover{background-color:var(--primary-light-variant)}
        .split-item-row{display:flex;gap:.5rem;align-items:center;margin-bottom:.5rem}.split-item-row select,.split-item-row input{flex:1}
        .split-item-row button{flex-shrink:0;width:auto;padding:.5rem .75rem;font-size:1rem;line-height:1;background-color:#ef4444}
        #total-split-amount{font-size:1.25rem;font-weight:700;text-align:right;margin-top:1rem;color:var(--primary-dark-variant)}
        table{width:100%;border-collapse:collapse;margin-top:1rem;font-size:.875rem}th,td{padding:.75rem .5rem;border:1px solid var(--border-color-light);text-align:center}
        tr.split-group-start > td{border-top:2px solid var(--primary-color) !important}
        tr.split-child > td{border-top:1px dashed #ccc !important}
        .split-child .split-info-cell{color:#9ca3af}
        .calendar-grid-container{display:grid;grid-template-columns:repeat(7,1fr);gap:4px;text-align:center}.calendar-day-header{font-weight:700;font-size:.8rem;padding-bottom:4px}.calendar-day-cell{border:1px solid var(--border-color-light);border-radius:.5rem;padding:4px;min-height:60px;display:flex;flex-direction:column;align-items:center;font-size:.8rem}.calendar-expense-amount{font-size:.7rem;color:red;font-weight:700;margin-top:4px}
        .scroll-table{overflow-x:auto}
        button, input, select { min-height: 48px; font-size: 1.1rem; }
        .tab-buttons button { min-height: 48px; font-size: 1rem; }
        input[type="date"], input[type="number"], input[type="text"], select { font-size: 1.1rem; padding: 0.75rem 0.5rem; }
        @media (max-width: 600px) {
            main, section { padding: 0.5rem; }
            h1, h2 { font-size: 1.1rem; }
            table th, table td { font-size: 0.95rem; padding: 0.5rem 0.25rem; }
        }

        /* Custom Modal Styles */
        .custom-modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .custom-modal-content {
            background: var(--card-bg-light);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 90%;
            width: 350px;
            color: var(--text-color-light);
        }
        .custom-modal-content h3 {
            margin-top: 0;
            color: var(--primary-dark-variant);
        }
        .custom-modal-content p {
            margin-bottom: 20px;
        }
        .custom-modal-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .custom-modal-buttons button {
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            flex: 1;
        }
        .custom-modal-buttons .confirm-btn {
            background-color: var(--primary-color);
            color: #fff;
            border: none;
        }
        .custom-modal-buttons .confirm-btn:hover {
            background-color: var(--primary-light-variant);
        }
        .custom-modal-buttons .cancel-btn {
            background-color: #ccc;
            color: #333;
            border: none;
        }
        .custom-modal-buttons .cancel-btn:hover {
            background-color: #bbb;
        }
        .custom-modal-buttons .alert-btn {
            background-color: var(--primary-color);
            color: #fff;
            border: none;
            width: 100%;
        }
        .custom-modal-buttons .alert-btn:hover {
            background-color: var(--primary-light-variant);
        }

        /* 新しいスクロールコンテナのスタイル */
        .scroll-graph-container {
            overflow-x: auto; /* 横スクロールを有効にする */
            width: 100%; /* 親要素の幅に合わせる */
            padding-bottom: 15px; /* スクロールバーのための余白 */
        }
        .scroll-graph-container canvas {
            display: block; /* 余分なスペースをなくす */
            height: 300px; /* グラフの高さは固定 */
            /* widthはJSで動的に設定される */
        }

    </style>
</head>
<body>
    <header>
        <img src="icon-512.png" alt="かものはし家計簿ロゴ">
        <h1>かものはし家計簿</h1>
    </header>
    <main id="mainContent">
        <div id="homeSection">
             <section>
                <h2><span style="font-size:1.5rem;margin-right:8px;">📷</span>レシート自動入力 (OCR)</h2>
                <input type="file" id="receipt-uploader" accept="image/*" capture="environment">
                <button id="process-receipts-btn" style="margin-top:0.5rem;">選択したレシートを読み取る</button>
                <div id="ocr-status" style="text-align:center;margin-top:1rem;font-weight:bold;"></div>
                <div id="ocr-results" style="margin-top:1rem;display:flex;flex-direction:column;gap:8px;"></div>
            </section>
            <section>
                <h2>支出・収入の記録</h2>
                <form id="recordForm">
                    <div style="display:flex;gap:1rem;"><input type="date" id="date" required><select id="type"><option value="expense">支出</option><option value="income">収入</option></select></div>
                    <input type="text" id="place" placeholder="場所（例：スーパーA）" required>
                    <div id="split-items-container" class="space-y-2 border-t border-b py-4 my-2"></div>
                    <button type="button" id="add-split-item-btn" style="background-color:#e5e7eb;color:#1f2937;">＋ 項目を追加</button>
                    <div id="total-split-amount">合計: ¥0</div>
                    <input type="text" id="tags" placeholder="タグ（グループ全体に適用）">
                    <input type="text" id="memo" placeholder="備考（グループ全体に適用）">
                    <button type="submit">記録</button>
                </form>
            </section>
            <section>
                <h2>
                    <input type="month" id="monthSelector" style="font-size:1.25rem;border:none;padding-left:0;width:auto;">の状況
                </h2>
                <div id="budgetSortControls" style="display:flex; gap: 8px; margin-bottom: 1rem; align-items: center;">
                    <label for="budgetSortBy" style="font-size: 0.9rem; margin-right: 4px;">並べ替え:</label>
                    <select id="budgetSortBy" style="flex: 1; padding: 0.5rem; font-size: 0.9rem; min-height: unset; margin-bottom: 0;">
                        <option value="genre">ジャンル</option>
                        <option value="budget">予算</option>
                        <option value="spent">支出</option>
                        <option value="remaining">残額</option>
                    </select>
                    <button id="budgetSortDirection" style="width: auto; padding: 0.5rem 0.75rem; font-size: 0.9rem; min-height: unset; margin-bottom: 0;">▲</button>
                </div>
                <div id="budgetTableArea" style="margin-bottom:1rem;"></div>
                 <div id="budgetProgressBars" style="margin-top:1.5rem;"></div>
                <div class="calendar-grid-container" style="margin-top:1.5rem;"></div>
            </section>
            <section>
              <h2>口座残高</h2>
              <div style="display:flex;gap:8px;align-items:center;">
                <input type="number" id="accountBalanceInput" placeholder="現在の口座残高" style="flex:1;">
                <button id="saveAccountBalanceBtn" style="width:auto;">保存</button>
              </div>
              <div id="balanceGraphArea" style="margin:1rem 0;"></div>
            </section>
            <section>
                    <h2>場所別支出</h2>
                <div style="display:flex; gap: 8px; margin-bottom: 1rem; align-items: center;">
                    <label for="spendingPlaceLimit" style="font-size: 0.9rem; margin-right: 4px;">表示項目数:</label>
                    <input type="number" id="spendingPlaceLimit" value="10" min="1" style="flex: 1; padding: 0.5rem; font-size: 0.9rem; min-height: unset; margin-bottom: 0;">
                    <button id="updateSpendingPlaceGraphBtn" style="width: auto; padding: 0.5rem 0.75rem; font-size: 0.9rem; min-height: unset; margin-bottom: 0;">更新</button>
                </div>
                <div id="spendingByPlaceGraphArea" style="margin:1rem 0;"></div>
            </section>
            <section>
                <h2>財務健全性スコアとアドバイス</h2>
                <div style="display:flex; justify-content:center; align-items:center; flex-direction:column; margin-bottom:1rem;">
                    <div id="financialHealthScoreDisplay" style="font-size:3rem; font-weight:bold; color:var(--primary-color);">--</div>
                    <p style="font-size:0.9rem; color:#666;">（今月の財務健全性スコア）</p>
                </div>
                <div id="financialHealthInsights" style="background-color:var(--background-light); padding:1rem; border-radius:.5rem;">
                    <p style="text-align:center; color:#999;">データがありません。</p>
                </div>
            </section>
            <section>
                <h2>履歴</h2>
                 <button id="monthlyReportBtn" style="margin-bottom:1rem;">📊 月次レポートを見る</button>
                <div id="monthlyReportArea" style="margin-top:1rem; margin-bottom:1rem;"></div>
                <div class="scroll-table"><table><thead><tr><th>日付</th><th>場所</th><th>金額</th><th>ジャンル</th><th>メモ</th><th>タグ</th><th>操作</th></tr></thead><tbody id="historyBody"></tbody></table></div>
            </section>
        </div>
        <div id="settingsSection" style="display:none;">
            <section>
                <h2>Google Drive バックアップ</h2>
                <div id="auth-status" style="margin-bottom:1rem;font-weight:bold;">初期化中...</div>
                <div style="display:flex;gap:8px;">
                    <button id="authorize_button" style="background-color:#4285F4;visibility:hidden;">Googleでログイン</button>
                    <button id="signout_button" style="display:none;background-color:#db4437;">ログアウト</button>
                </div>
                <div style="display:flex;gap:8px;margin-top:8px;">
                    <button id="backup_button" disabled>Driveへバックアップ</button>
                    <button id="restore_button" disabled>Driveから復元</button>
                </div>
                <div id="backup-status" style="text-align:center;margin-top:1rem;"></div>
            </section>
            <section>
                <h2>ジャンルの管理</h2>
                <div style="display:flex;gap:8px;">
                    <input type="text" id="newGenre" placeholder="新しいジャンル名">
                    <select id="newGenreType">
                        <option value="">通常</option>
                        <option value="fixed">定期（固定）</option>
                        <option value="variable">定期（変動）</option>
                    </select>
                    <input type="number" id="newGenreDueDay" min="1" max="31" placeholder="発生日 (任意)">
                    <button id="addGenreBtn" style="width:auto;flex-shrink:0;">追加</button>
                </div>
                <div id="genreList" style="margin-top:1rem;"></div>
            </section>
            <section>
                <h2>予算の設定</h2>
                <div style="display:flex;gap:8px;"><select id="budgetGenre" style="flex:1;"></select><input type="number" id="budgetAmount" placeholder="金額" style="flex:1;"><button id="setBudgetBtn" style="width:auto;flex-shrink:0;">設定</button></div>
                <button id="copyBudgetBtn" style="width:100%;margin-top:8px;">先月の予算をコピー</button>
            </section>
            <section>
                <h2>定期的な取引の管理</h2>
                <p style="font-size:0.9rem;color:#666;margin-bottom:1rem;">
                    「定期（固定）」または「定期（変動）」に設定されたジャンルは、毎月自動的に取引が生成されます。<br>
                    発生日は各ジャンルで設定された日付が優先され、未設定の場合は「変動支出の発生日」が適用されます。
                </p>
                <button id="generateRecurringTransactionsBtn" style="margin-bottom:1rem;">今月の定期取引を生成</button>
                <div id="recurringTransactionsList" style="margin-top:1rem;"></div>
            </section>
            <section>
                <h2>Gemini API キー設定</h2>
                <input type="password" id="apiKeyInput" placeholder="ここにGemini APIキーを貼り付け">
                <button id="saveApiKeyBtn" style="margin-top:0.5rem;">APIキーを保存</button>
            </section>
            <section>
                <h2>データのエクスポート / インポート</h2>
                <button id="exportDataBtn">📤 エクスポート</button>
                <input type="file" id="importFileInput" style="display:none;" accept=".json">
                <button id="importDataButton" style="margin-top:8px;">📥 インポート</button>
            </section>
            <section>
                <h2>変動支出確認日と発生日</h2>
                <div style="display:flex;gap:8px;align-items:center;">
                    <input type="number" id="variableExpenseCheckDay" min="1" max="31" placeholder="確認日 (毎月)" style="flex:1;">
                    <button id="saveVariableExpenseCheckDayBtn" style="width:auto;">保存</button>
                </div>
                <div style="display:flex;gap:8px;align-items:center;margin-top:8px;">
                    <input type="number" id="variableExpenseDueDay" min="1" max="31" placeholder="発生日 (毎月)" style="flex:1;">
                    <button id="saveVariableExpenseDueDayBtn" style="width:auto;">保存</button>
                </div>
                <div id="variableExpenseStatus" style="margin-top:0.5rem;color:#666;font-size:0.95rem;"></div>
            </section>
        </div>
    </main>
    <div class="tab-buttons">
        <button id="homeTab" class="active"><span>🏠</span>ホーム</button>
        <button id="settingsTab"><span>⚙️</span>設定</button>
    </div>

    <!-- 履歴編集モーダル -->
    <div id="editTransactionModal" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);background:#fff;padding:1rem;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,0.1);z-index:1000;">
        <h2>履歴の編集</h2>
        <form id="editTransactionForm">
            <label>日付: <input type="date" id="editDate" required></label><br>
            <label>場所: <input type="text" id="editPlace" required></label><br>
            <label>金額: <input type="number" id="editAmount" required></label><br>
            <label>ジャンル: 
                <select id="editGenre"></select>
            </label><br>
            <label>メモ: <input type="text" id="editMemo"></label><br>
            <label>タグ: <input type="text" id="editTags"></label><br>
            <button type="submit">保存</button>
            <button type="button" id="cancelEditBtn">キャンセル</button>
        </form>
    </div>
    <div id="modalOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:999;"></div>
    
    <!-- ジャンル編集モーダル -->
    <div id="editGenreModal" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);background:#fff;padding:1rem;border-radius:8px;box-shadow:0 4px 6px rgba(0,0,0,0.1);z-index:1000;">
        <h2>ジャンルの編集</h2>
        <form id="editGenreForm">
            <label>ジャンル名: <input type="text" id="editGenreName" required></label><br>
            <label>ジャンルタイプ: 
                <select id="editGenreType">
                    <option value="">通常</option>
                    <option value="fixed">定期（固定）</option>
                    <option value="variable">定期（変動）</option>
                </select>
            </label><br>
            <label>発生日: <input type="number" id="editGenreDueDay" min="1" max="31" placeholder="発生日 (任意)"></label><br>
            <button type="submit">保存</button>
            <button type="button" id="cancelEditGenreBtn">キャンセル</button>
        </form>
    </div>
    <div id="editGenreOverlay" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:999;"></div>

    <!-- カスタムアラート/確認モーダル -->
    <div id="customAlertModal" class="custom-modal-overlay">
        <div class="custom-modal-content">
            <h3 id="customAlertTitle"></h3>
            <p id="customAlertMessage"></p>
            <div class="custom-modal-buttons">
                <button class="alert-btn" id="customAlertOk">OK</button>
            </div>
        </div>
    </div>

    <div id="customConfirmModal" class="custom-modal-overlay">
        <div class="custom-modal-content">
            <h3 id="customConfirmTitle"></h3>
            <p id="customConfirmMessage"></p>
            <div class="custom-modal-buttons">
                <button class="confirm-btn" id="customConfirmYes">はい</button>
                <button class="cancel-btn" id="customConfirmNo">いいえ</button>
            </div>
        </div>
    </div>

    <!-- インポートオプションモーダル -->
    <div id="importOptionsModal" class="custom-modal-overlay">
        <div class="custom-modal-content" style="max-width: 450px;">
            <h3 id="importOptionsTitle">インポートオプション</h3>
            <p>インポートする項目を選択してください。選択しない項目は現在のデータが保持されます。</p>
            <div style="text-align: left; margin-bottom: 15px;">
                <label style="display: block; margin-bottom: 8px;">
                    <input type="checkbox" id="importTransactions" checked> 履歴 (<span id="importTransactionsCount">0</span>件)
                </label>
                <label style="display: block; margin-bottom: 8px;">
                    <input type="checkbox" id="importGenres" checked> ジャンル (<span id="importGenresCount">0</span>件)
                </label>
                <label style="display: block; margin-bottom: 8px;">
                    <input type="checkbox" id="importBudgets" checked> 予算 (<span id="importBudgetsCount">0</span>ヶ月分)
                </label>
                <label style="display: block;">
                    <input type="checkbox" id="importRolloverGenres" checked> 繰越ジャンル (<span id="importRolloverGenresCount">0</span>件)
                </label>
                <label style="display: block;">
                    <input type="checkbox" id="importPlaceGenreMap" checked> 場所別ジャンル学習データ (<span id="importPlaceGenreMapCount">0</span>件)
                </label>
            </div>
            <div class="custom-modal-buttons">
                <button class="confirm-btn" id="importOptionsProceed">インポート</button>
                <button class="cancel-btn" id="importOptionsCancel">キャンセル</button>
            </div>
        </div>
    </div>

    <script>
        // --- グローバル変数 ---
        let transactions = [];
        let genres = [
          { name: '食費', type: '' },
          { name: '家賃', type: 'fixed' },
          { name: 'クレジットカード', type: 'variable' },
        ];
        let budgetsByMonth = {};
        let rolloverGenres = [];
        let currentMonth = new Date().toISOString().slice(0, 7);
        let budgetPieChart = null;
        let accountBalance = 0;
        let variableExpenseCheckDay = 1;
        let variableExpenseDueDay = 1; // Added initialization for variableExpenseDueDay
        const LOCAL_STORAGE_KEY = 'kakeiboData';
        const PLACE_GENRE_MAP_KEY = 'placeGenreMap'; // 場所とジャンルの関連性を保存するキー
        let spendingByPlaceChart = null; // 場所別支出グラフのインスタンスを保持する変数
        let placeGenreMap = {}; // 場所とジャンルの関連性を保持するオブジェクト
        let budgetSortColumn = 'genre'; // Default sort column
        let budgetSortDirection = 'asc'; // Default sort direction
        let spendingPlaceLimit = 3; // 場所別支出グラフの表示項目数

        // --- Google Drive API関連 ---
        const API_KEY = 'AIzaSyA8SHDfUl1CWayCmq6oGREjnxWR6R8vPkM'; // ★GitHubに上げる際は必ずプレースホルダーに戻すこと！
        const CLIENT_ID = '98738563895-d80ev131bgogmct7hi0qv3ojopu52dsj.apps.googleusercontent.com';
        const DISCOVERY_DOC = 'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest';
        const SCOPES = 'https://www.googleapis.com/auth/drive.file';
        const BACKUP_FILENAME = 'kakeibo_backup.json';
        // tokenClient, gapiInited, gsiInited, backupFileId はグローバルで定義済み

        // --- Google API初期化コールバック (グローバルスコープに移動) ---
        // gapiLoaded, gisLoaded, initializeGapiClient はHTMLのhead内のscriptタグで定義済み
        // window.gapiLoaded = function() { ... } と window.gisLoaded = function() { ... } は削除済み

        function maybeInitAuth() {
            const authStatus = document.getElementById('auth-status');
            if (gapiInited && gsiInited) {
                authStatus.textContent = '未ログイン';
                document.getElementById('authorize_button').style.visibility = 'visible';
                if (localStorage.getItem('google_auth_loggedin') === 'true') {
                   handleAuthClick(true);
                }
            }
        }

        // --- カスタムモーダル関数 ---
        function showAlert(message, title = 'お知らせ') {
            const modal = document.getElementById('customAlertModal');
            document.getElementById('customAlertTitle').textContent = title;
            document.getElementById('customAlertMessage').textContent = message;
            modal.style.display = 'flex';
            return new Promise(resolve => {
                document.getElementById('customAlertOk').onclick = () => {
                    modal.style.display = 'none';
                    resolve();
                };
            });
        }

        function showConfirm(message, title = '確認') {
            const modal = document.getElementById('customConfirmModal');
            document.getElementById('customConfirmTitle').textContent = title;
            document.getElementById('customConfirmMessage').textContent = message;
            modal.style.display = 'flex';
            return new Promise(resolve => {
                document.getElementById('customConfirmYes').onclick = () => {
                    modal.style.display = 'none';
                    resolve(true);
                };
                document.getElementById('customConfirmNo').onclick = () => {
                    modal.style.display = 'none';
                    resolve(false);
                };
            });
        }

        function showImportOptionsModal(importedData) {
            const modal = document.getElementById('importOptionsModal');
            document.getElementById('importTransactionsCount').textContent = importedData.transactions ? importedData.transactions.length : 0;
            document.getElementById('importGenresCount').textContent = importedData.genres ? importedData.genres.length : 0;
            document.getElementById('importBudgetsCount').textContent = importedData.budgetsByMonth ? Object.keys(importedData.budgetsByMonth).length : 0;
            document.getElementById('importRolloverGenresCount').textContent = importedData.rolloverGenres ? importedData.rolloverGenres.length : 0;
            document.getElementById('importPlaceGenreMapCount').textContent = importedData.placeGenreMap ? Object.keys(importedData.placeGenreMap).length : 0; // 新しいカウント

            document.getElementById('importTransactions').checked = !!importedData.transactions;
            document.getElementById('importGenres').checked = !!importedData.genres;
            document.getElementById('importBudgets').checked = !!importedData.budgetsByMonth;
            document.getElementById('importRolloverGenres').checked = !!importedData.rolloverGenres;
            document.getElementById('importPlaceGenreMap').checked = !!importedData.placeGenreMap; // 新しいチェックボックス

            modal.style.display = 'flex';

            return new Promise(resolve => {
                document.getElementById('importOptionsProceed').onclick = () => {
                    const selections = {
                        transactions: document.getElementById('importTransactions').checked,
                        genres: document.getElementById('importGenres').checked,
                        budgetsByMonth: document.getElementById('importBudgets').checked,
                        rolloverGenres: document.getElementById('importRolloverGenres').checked,
                        placeGenreMap: document.getElementById('importPlaceGenreMap').checked // 新しい選択項目
                    };
                    modal.style.display = 'none';
                    resolve(selections);
                };
                document.getElementById('importOptionsCancel').onclick = () => {
                    modal.style.display = 'none';
                    resolve(null); // User cancelled
                };
            });
        }


        // --- データ管理 ---
        function generateUniqueId() { return Date.now().toString(36) + Math.random().toString(36).substring(2, 9); }

        function loadData() {
            const storedData = localStorage.getItem(LOCAL_STORAGE_KEY);
            if (!storedData) return;
            const data = JSON.parse(storedData);
            transactions = data.transactions || [];
            genres = data.genres || [ { name: '食費', type: '' }, { name: '家賃', type: 'fixed' }, { name: 'クレジットカード', type: 'variable' } ];
            budgetsByMonth = data.budgetsByMonth || data.budgets || {};
            rolloverGenres = data.rolloverGenres || [];
            accountBalance = parseInt(localStorage.getItem('accountBalance') || '0');
            variableExpenseCheckDay = parseInt(localStorage.getItem('variableExpenseCheckDay') || '1');
            variableExpenseDueDay = parseInt(localStorage.getItem('variableExpenseDueDay') || '1');
            
            // 場所とジャンルの関連性マップを読み込む
            const storedPlaceGenreMap = localStorage.getItem(PLACE_GENRE_MAP_KEY);
            if (storedPlaceGenreMap) {
                placeGenreMap = JSON.parse(storedPlaceGenreMap);
            }
        }

        function saveData() {
            const dataToSave = { transactions, genres, budgetsByMonth, rolloverGenres, placeGenreMap }; // placeGenreMapも保存
            localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
            localStorage.setItem('accountBalance', accountBalance);
            localStorage.setItem('variableExpenseCheckDay', variableExpenseCheckDay);
            localStorage.setItem('variableExpenseDueDay', variableExpenseDueDay);
            // 場所とジャンルの関連性マップを保存する
            localStorage.setItem(PLACE_GENRE_MAP_KEY, JSON.stringify(placeGenreMap));
        }

        // --- UI更新 ---
        function renderApp() {
            document.getElementById('monthSelector').value = currentMonth;
            document.getElementById('accountBalanceInput').value = accountBalance || '';
            document.getElementById('variableExpenseCheckDay').value = variableExpenseCheckDay || '';
            document.getElementById('variableExpenseDueDay').value = variableExpenseDueDay || '';
            document.getElementById('variableExpenseStatus').textContent = `変動支出の発生日は、各ジャンルで設定された日付（未設定の場合は毎月${variableExpenseDueDay}日）です。`;

            updateHistoryTable();
            updateGenreManagementList();
            updateBudgetGenreSelector();
            updateSplitItemGenreSelects();
            updateCalendarView();
            updateBudgetTable();
            updateBudgetProgressBars();
            renderBalanceGraph();
            renderSpendingByPlaceGraph(); // 場所別支出グラフをレンダリング
            renderFinancialHealthSection(); // 財務健全性スコアとアドバイスをレンダリング
            checkVariableExpensesIfNeeded();
            renderRecurringTransactionsList(); // 新しい関数を呼び出す
        }

        function switchTab(tabName) {
            document.getElementById('homeSection').style.display = (tabName === 'home' ? 'block' : 'none');
            document.getElementById('settingsSection').style.display = (tabName === 'settings' ? 'block' : 'none');
            document.getElementById('homeTab').classList.toggle('active', tabName === 'home');
            document.getElementById('settingsTab').classList.toggle('active', tabName === 'settings');
        }

        function updateGenreManagementList() {
            const genreListDiv = document.getElementById('genreList');
            genreListDiv.innerHTML = '';
            genres.forEach((g, index) => {
                const isRolloverEnabled = rolloverGenres.includes(g.name);
                const itemDiv = document.createElement('div');
                itemDiv.style.cssText = 'display:flex;justify-content:space-between;align-items:center;padding:4px;border-bottom:1px solid var(--border-color-light)';
                itemDiv.setAttribute('draggable', 'true');
                itemDiv.setAttribute('data-index', index);
                itemDiv.innerHTML = `
                    <span>${g.name || ''} (${g.type || '通常'})</span>
                    <div style="display:flex;align-items:center;gap:8px;">
                        <input type="number" class="genre-due-day" data-genre="${g.name}" value="${g.dueDay || ''}" min="1" max="31" placeholder="発生日">
                        <label style="font-size:0.8rem;">
                            <input type="checkbox" class="rollover-checkbox" data-genre="${g.name}" ${isRolloverEnabled ? 'checked' : ''}> 繰越
                        </label>
                        <button class="edit-genre-btn" data-index="${index}" style="width:auto;padding:2px 6px;background-color:#4caf50;color:#fff;">編集</button>
                        <button class="delete-btn" data-genre="${g.name}" style="width:auto;padding:2px 6px;background-color:#ef4444;">&times;</button>
                    </div>`;
                genreListDiv.appendChild(itemDiv);

                // イベントリスナーを追加
                itemDiv.querySelector('.edit-genre-btn').addEventListener('click', (e) => openEditGenreModal(e.target.dataset.index));
                itemDiv.querySelector('.delete-btn').addEventListener('click', async (e) => {
                    const confirmed = await showConfirm(`「${e.target.dataset.genre}」を削除しますか？`);
                    if (confirmed) deleteGenre(e.target.dataset.genre);
                });
                itemDiv.querySelector('.rollover-checkbox').addEventListener('change', (e) => handleRolloverChange(e.target.dataset.genre, e.target.checked));
                itemDiv.querySelector('.genre-due-day').addEventListener('change', (e) => updateGenreDueDay(e.target.dataset.genre, e.target.value));
            });
        }

        let draggedItemIndex = null;

        function handleDragStart(e) {
            draggedItemIndex = parseInt(e.target.getAttribute('data-index'));
            e.target.style.opacity = '0.5'; // ドラッグ中のアイテムを半透明にする
        }

        function handleDragOver(e) {
            e.preventDefault(); // ドロップを許可する
            e.target.style.border = '2px dashed var(--primary-color)'; // ドラッグ中のアイテムの上に枠線を表示
        }

        function handleDrop(e) {
            e.preventDefault();
            const targetIndex = parseInt(e.target.closest('[data-index]').getAttribute('data-index'));
            if (draggedItemIndex !== null && targetIndex !== null && draggedItemIndex !== targetIndex) {
                // ジャンルの順序を入れ替える
                const draggedItem = genres[draggedItemIndex];
                genres.splice(draggedItemIndex, 1);
                genres.splice(targetIndex, 0, draggedItem);

                // データを保存してUIを更新
                saveData();
                updateGenreManagementList();
            }
        }

        function handleDragEnd(e) {
            e.target.style.opacity = '1'; // ドラッグ終了後に透明度を元に戻す
            document.querySelectorAll('[data-index]').forEach(item => {
                item.style.border = ''; // 枠線を消す
            });
        }

        function updateGenreDueDay(genreName, dueDay) {
            const genre = genres.find(g => g.name === genreName);
            if (genre) {
                genre.dueDay = parseInt(dueDay) || null;
                saveData();
            }
        }

        function updateHistoryTable() {
            const historyBody = document.getElementById('historyBody');
            historyBody.innerHTML = '';
            const filtered = transactions.filter(t => t.date && t.date.startsWith(currentMonth));
            const sorted = filtered.sort((a, b) => b.date.localeCompare(a.date) || (b.timestamp > a.timestamp ? -1 : 1));
            sorted.forEach((transaction, index) => {
                const row = historyBody.insertRow();
                let isSplitChild = transaction.splitGroupId && index > 0 && sorted[index - 1].splitGroupId === transaction.splitGroupId;
                if (transaction.splitGroupId && !isSplitChild) row.classList.add('split-group-start');
                if (isSplitChild) row.classList.add('split-child');
                const infoCell = (content) => isSplitChild ? `<span class="split-info-cell">${content || ''}</span>` : `<span>${content || ''}</span>`;
                row.innerHTML = `
                    <td>${infoCell(transaction.date || '')}</td>
                    <td>${infoCell(transaction.place || '')}</td>
                    <td style="color:${transaction.type === 'expense' ? 'red' : 'green'};">${new Intl.NumberFormat().format(transaction.amount || 0)}円</td>
                    <td>${transaction.genre || ''}</td>
                    <td>${infoCell(transaction.memo || '')}</td>
                    <td>${infoCell(transaction.tags || '')}</td>
                    <td>
                        <button class="edit-btn" data-timestamp="${transaction.timestamp}" style="background-color:#4caf50;padding:4px 8px;width:auto;">編集</button>
                        <button class="delete-btn" data-timestamp="${transaction.timestamp}" style="background-color:#ef4444;padding:4px 8px;width:auto;">削除</button>
                    </td>`;
                row.querySelector('.delete-btn').addEventListener('click', async (e) => {
                    const txToDelete = transactions.find(t => t.timestamp === e.target.dataset.timestamp);
                    if (!txToDelete) return;
                    let msg = 'この記録を削除しますか？';
                    if (txToDelete.splitGroupId && transactions.filter(t => t.splitGroupId === txToDelete.splitGroupId).length > 1) {
                        msg = 'これは分割記録の一部です。この項目のみ削除しますか？';
                    }
                    const confirmed = await showConfirm(msg);
                    if (confirmed) deleteTransaction(e.target.dataset.timestamp);
                });
                row.querySelector('.edit-btn').addEventListener('click', (e) => editTransaction(e.target.dataset.timestamp));
            });
        }

        function updateCalendarView() {
            const calendarContainer = document.querySelector('.calendar-grid-container');
            calendarContainer.innerHTML = '';
            const dayHeaders = ['日','月','火','水','木','金','土'];
            dayHeaders.forEach(day => calendarContainer.insertAdjacentHTML('beforeend', `<div class="calendar-day-header">${day}</div>`));
            const [year, month] = currentMonth.split('-').map(Number);
            const firstDay = new Date(year, month - 1, 1).getDay();
            const daysInMonth = new Date(year, month, 0).getDate();
            const dailyTotals = {};
            transactions.filter(t => t.date && t.date.startsWith(currentMonth) && t.type === 'expense').forEach(t => {
                const day = new Date(t.date).getDate();
                dailyTotals[day] = (dailyTotals[day] || 0) + t.amount;
            });
            for (let i = 0; i < firstDay; i++) calendarContainer.insertAdjacentHTML('beforeend', '<div></div>');
            for (let day = 1; day <= daysInMonth; day++) {
                let content = `<span class="calendar-day-number">${day}</span>`;
                if (dailyTotals[day]) content += `<span class="calendar-expense-amount">${new Intl.NumberFormat().format(dailyTotals[day])}円</span>`;
                calendarContainer.insertAdjacentHTML('beforeend', `<div class="calendar-day-cell">${content}</div>`);
            }
        }

        function updateBudgetTable() {
            const area = document.getElementById('budgetTableArea');
            const monthlyBudget = budgetsByMonth[currentMonth] || {};
            
            // 予算データを配列に変換
            const budgetData = Object.keys(monthlyBudget).map(genreName => {
                const budget = monthlyBudget[genreName];
                const spent = transactions
                    .filter(t => t.date && t.date.startsWith(currentMonth) && t.genre === genreName && t.type === 'expense')
                    .reduce((sum, t) => sum + t.amount, 0);
                const remaining = budget - spent;
                return { genre: genreName, budget, spent, remaining };
            });

            // ソートロジック
            budgetData.sort((a, b) => {
                let valA, valB;
                switch (budgetSortColumn) {
                    case 'genre':
                        valA = a.genre;
                        valB = b.genre;
                        return budgetSortDirection === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                    case 'budget':
                        valA = a.budget;
                        valB = b.budget;
                        break;
                    case 'spent':
                        valA = a.spent;
                        valB = b.spent;
                        break;
                    case 'remaining':
                        valA = a.remaining;
                        valB = b.remaining;
                        break;
                    default:
                        return 0; // No sort
                }
                return budgetSortDirection === 'asc' ? valA - valB : valB - valA;
            });

            let html = '<table style="width:100%;border-collapse:collapse;"><thead><tr><th>ジャンル</th><th>予算</th><th>支出</th><th>残額</th></tr></thead><tbody>';
            budgetData.forEach(item => {
                html += `<tr>
                    <td>${item.genre}</td>
                    <td>${new Intl.NumberFormat().format(item.budget)}円</td>
                    <td>${new Intl.NumberFormat().format(item.spent)}円</td>
                    <td>${new Intl.NumberFormat().format(item.remaining)}円</td>
                </tr>`;
            });
            html += '</tbody></table>';
            area.innerHTML = html;
        }

        function updateBudgetProgressBars(){} // 実装は省略

        function addSplitItemRow(container) {
            const row = document.createElement('div');
            row.className = 'split-item-row';
            const genreSelect = document.createElement('select');
            genreSelect.className = 'split-genre';
            updateGenreOptions(genreSelect);
            const amountInput = document.createElement('input');
            amountInput.type = 'number';
            amountInput.className = 'split-amount';
            amountInput.placeholder = '金額';
            amountInput.min = '0';
            amountInput.addEventListener('input', updateSplitTotal);
            const deleteBtn = document.createElement('button');
            deleteBtn.type = 'button';
            deleteBtn.textContent = '✖';
            deleteBtn.addEventListener('click', () => { if (container.querySelectorAll('.split-item-row').length > 1) { row.remove(); updateSplitTotal(); }});
            row.appendChild(genreSelect);
            row.appendChild(amountInput);
            row.appendChild(deleteBtn);
            container.appendChild(row);
        }

        function updateGenreOptions(selectElement) {
            const currentVal = selectElement.value;
            selectElement.innerHTML = '';
            genres.forEach(g => {
                const option = document.createElement('option');
                option.value = g.name;
                option.textContent = g.name;
                selectElement.appendChild(option);
            });
            if(currentVal) selectElement.value = currentVal;
        }

        function updateSplitItemGenreSelects() { document.querySelectorAll('.split-genre').forEach(updateGenreOptions); }

        function updateSplitTotal() {
            const container = document.getElementById('split-items-container');
            const amounts = Array.from(container.querySelectorAll('.split-amount'));
            const total = amounts.reduce((sum, input) => sum + (parseInt(input.value) || 0), 0);
            document.getElementById('total-split-amount').textContent = `合計: ${new Intl.NumberFormat('ja-JP', { style: 'currency', currency: 'JPY' }).format(total)}`;
        }

        async function handleRecordSubmit(e) {
            e.preventDefault();
            const date = document.getElementById('date').value,
                place = document.getElementById('place').value,
                type = document.getElementById('type').value,
                memo = document.getElementById('memo').value,
                tags = document.getElementById('tags').value,
                splitItems = document.querySelectorAll('.split-item-row');
            if (!place) { await showAlert('場所を入力してください。'); return; }
            const splitGroupId = generateUniqueId();
            let recordsToAdd = [];
            splitItems.forEach(item => {
                const genre = item.querySelector('.split-genre').value;
                const amount = parseInt(item.querySelector('.split-amount').value);
                if (genre && amount > 0) {
                    recordsToAdd.push({ date, place, type, memo, tags, genre, amount, splitGroupId, timestamp: generateUniqueId() });
                    // 場所とジャンルの関連性を学習
                    if (placeGenreMap[place]) {
                        placeGenreMap[place][genre] = (placeGenreMap[place][genre] || 0) + 1;
                    } else {
                        placeGenreMap[place] = { [genre]: 1 };
                    }
                }
            });
            if (recordsToAdd.length > 0) {
                transactions.push(...recordsToAdd);
                saveData();
                renderApp();
                document.getElementById('recordForm').reset();
                document.getElementById('date').valueAsDate = new Date();
                const container = document.getElementById('split-items-container');
                container.innerHTML = '';
                addSplitItemRow(container);
                updateSplitTotal();
            } else {
                await showAlert('有効な金額を持つ項目がありません。');
            }
        }

        function deleteTransaction(timestamp) {
            transactions = transactions.filter(t => t.timestamp !== timestamp);
            saveData();
            renderApp();
        }

        async function addGenre() {
            const newGenreInput = document.getElementById('newGenre');
            const newGenreType = document.getElementById('newGenreType').value;
            const newGenreDueDay = parseInt(document.getElementById('newGenreDueDay').value) || null;
            const newGenreName = newGenreInput.value.trim();

            if (newGenreName && !genres.some(g => g.name === newGenreName)) {
                genres.push({ name: newGenreName, type: newGenreType, dueDay: newGenreDueDay });
                saveData();
                renderApp();
                newGenreInput.value = '';
                document.getElementById('newGenreDueDay').value = '';
            } else if (genres.some(g => g.name === newGenreName)) {
                await showAlert('そのジャンル名はすでに存在します。');
            }
        }

        function deleteGenre(genreName) {
            genres = genres.filter(g => g.name !== genreName);
            rolloverGenres = rolloverGenres.filter(g => g !== genreName);
            saveData();
            renderApp();
        }

        function updateBudgetGenreSelector() {
            const budgetGenreSelect = document.getElementById('budgetGenre');
            if(!budgetGenreSelect) return;
            budgetGenreSelect.innerHTML = '';
            genres.forEach(g => {
                const option = document.createElement('option');
                option.value = g.name;
                option.textContent = g.name;
                budgetGenreSelect.appendChild(option);
            });
        }

        async function setBudget() {
             const genre = document.getElementById('budgetGenre').value;
             const amount = parseInt(document.getElementById('budgetAmount').value);
             if (genre && !isNaN(amount)) {
                if(!budgetsByMonth[currentMonth]) budgetsByMonth[currentMonth] = {};
                budgetsByMonth[currentMonth][genre] = amount;
                saveData();
                renderApp();
                await showAlert('予算を設定しました。');
             } else {
                await showAlert('ジャンルと金額を正しく入力してください。');
             }
        }

        async function copyLastMonthBudget() {
            const date = new Date(currentMonth + '-01');
            date.setMonth(date.getMonth() - 1);
            const lastMonthKey = date.toISOString().slice(0, 7);
            if (budgetsByMonth[lastMonthKey]) {
                const confirmed = await showConfirm(`${lastMonthKey}の予算をコピーしますか？現在の月（${currentMonth}）の予算は上書きされます。`);
                if (confirmed) {
                    budgetsByMonth[currentMonth] = { ...budgetsByMonth[lastMonthKey] };
                    saveData();
                    renderApp();
                    await showAlert(`${lastMonthKey}の予算をコピーしました。`);
                }
            } else {
                await showAlert('前月の予算データがありません。');
            }
        }

        function handleRolloverChange(genre, isChecked) {
            const index = rolloverGenres.indexOf(genre);
            if (isChecked && index === -1) rolloverGenres.push(genre);
            else if (!isChecked && index > -1) rolloverGenres.splice(index, 1);
            saveData();
        }

        async function exportData() {
            const dataStr = JSON.stringify({ transactions, genres, budgetsByMonth, rolloverGenres, placeGenreMap }, null, 2); // placeGenreMapもエクスポート
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `kakeibo_data_${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
            await showAlert('データをエクスポートしました。');
        }

        async function importData(file) {
            if (!file) {
                await showAlert('ファイルが選択されていません。');
                return;
            }
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);

                    // Show import options modal
                    const selections = await showImportOptionsModal(importedData);

                    if (selections) { // If not cancelled
                        if (selections.transactions) {
                            transactions = importedData.transactions || [];
                        }
                        if (selections.genres) {
                            genres = importedData.genres || [];
                        }
                        if (selections.budgetsByMonth) {
                            budgetsByMonth = importedData.budgetsByMonth || {};
                        }
                        if (selections.rolloverGenres) {
                            rolloverGenres = importedData.rolloverGenres || [];
                        }
                        // インポート時にplaceGenreMapも更新
                        if (selections.placeGenreMap && importedData.placeGenreMap) { // 選択されていて、データに含まれていれば
                            placeGenreMap = importedData.placeGenreMap;
                        } else if (!selections.placeGenreMap) { // 選択されていない場合は現在のデータを維持
                            // 何もしない
                        } else { // 選択されたがデータに含まれていない場合
                            placeGenreMap = {}; // 空にするか、既存のものを維持するかは要件次第だが、ここでは空にする
                        }
                        
                        saveData();
                        renderApp();
                        await showAlert('データをインポートしました。');
                    } else {
                        await showAlert('データのインポートをキャンセルしました。');
                    }
                } catch (err) {
                    console.error("Import error:", err);
                    await showAlert('ファイルの読み込みに失敗しました。ファイルが破損しているか、形式が正しくありません。');
                }
            };
            reader.readAsText(file);
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = error => reject(error);
            });
        }

        async function handleReceiptProcessing() {
            const uploader = document.getElementById('receipt-uploader');
            const statusDiv = document.getElementById('ocr-status');
            const resultsDiv = document.getElementById('ocr-results');
            const processBtn = document.getElementById('process-receipts-btn');

            processBtn.disabled = true;
            processBtn.textContent = '読み取り中...';

            try {
                const apiKey = localStorage.getItem('geminiApiKey');
                if (!apiKey) {
                    await showAlert('APIキーが設定されていません。「設定」画面でAPIキーを保存してください。');
                    switchTab('settings');
                    return;
                }

                const files = uploader.files;
                if (files.length === 0) {
                    await showAlert('レシート画像を選択してください。');
                    return;
                }
                if (files.length > 1) {
                    await showAlert('複数レシートの一括読み取りでは、一度に1枚の画像のみ選択してください。');
                    return;
                }

                statusDiv.textContent = '処理を開始します...';
                resultsDiv.innerHTML = '';
                const SAFE_LIMIT_PER_DAY = 50;
                const today = new Date().toISOString().slice(0, 10);
                let usageCount = parseInt(localStorage.getItem(`ocrUsage_${today}`) || '0');

                if (usageCount >= SAFE_LIMIT_PER_DAY) {
                    statusDiv.textContent = `1日の上限（${SAFE_LIMIT_PER_DAY}回）に達しました。`;
                    return;
                }

                const file = files[0];
                statusDiv.textContent = `${file.name} を読み取り中...`;

                let base64Image;
                try {
                    base64Image = await fileToBase64(file);
                } catch (fileError) {
                    console.error("OCR処理エラー: ファイルのBase64変換に失敗しました。", fileError);
                    await showAlert('レシート画像の読み込みに失敗しました。ファイルが破損しているか、形式が正しくありません。', 'エラー');
                    return;
                }

                const genAI = new window.GoogleGenerativeAI(apiKey);
                const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
                const prompt = `この1枚の画像に写っている全てのレシートを個別に認識し、各レシートから以下の情報を抽出し、必ずJSONの配列（リスト）形式で回答してください。- place: 店名 (文字列) - date: 日付 (YYYY-MM-DD形式の文字列) - total: 合計金額 (数値)`;
                const imagePart = { inlineData: { data: base64Image, mimeType: file.type } };
                
                let result;
                try {
                    result = await model.generateContent([prompt, imagePart]);
                } catch (apiError) {
                    console.error("OCR処理エラー: Gemini API呼び出しに失敗しました。", apiError);
                    let errorMessage = 'Gemini APIとの通信中にエラーが発生しました。';
                    if (apiError.message && apiError.message.includes('API key not valid')) {
                        errorMessage += ' APIキーが不正な可能性があります。設定を確認してください。';
                    } else if (apiError.message && apiError.message.includes('quota')) {
                        errorMessage += ' APIの使用制限に達した可能性があります。';
                    }
                    await showAlert(errorMessage, 'エラー');
                    return;
                }

                let responseText;
                try {
                    responseText = result.response.text().replace(/```json|```/g, '').trim();
                } catch (textError) {
                    console.error("OCR処理エラー: APIレスポンスのテキスト抽出に失敗しました。", textError);
                    await showAlert('APIからの応答が予期せぬ形式でした。', 'エラー');
                    return;
                }

                let resultsArray;
                try {
                    resultsArray = JSON.parse(responseText);
                } catch (parseError) {
                    console.error("OCR処理エラー: JSONパースに失敗しました。APIレスポンス:", responseText, parseError);
                    await showAlert('レシート情報の解析に失敗しました。APIからの応答が正しいJSON形式ではありませんでした。', 'エラー');
                    return;
                }

                if (resultsArray.length === 0) {
                    statusDiv.textContent = '画像からレシートを検出できませんでした。';
                    await showAlert('画像からレシートを検出できませんでした。より鮮明な画像をお試しください。', '情報');
                    return;
                }

                resultsArray.forEach(data => {
                    const card = document.createElement('div');
                    card.style.cssText = 'border: 1px solid #ccc; padding: 12px; cursor: pointer; border-radius: 8px;';
                    card.innerHTML = `<strong>店名:</strong> ${data.place||'不明'}<br><strong>日付:</strong> ${data.date||'不明'}<br><strong>合計:</strong> ${new Intl.NumberFormat().format(data.total||0)} 円`;
                    card.onclick = async () => {
                        document.getElementById('place').value = data.place || '';
                        if(data.date && data.date !== '不明') document.getElementById('date').value = data.date;
                        const container = document.getElementById('split-items-container');
                        container.innerHTML = '';
                        addSplitItemRow(container);
                        container.querySelector('.split-amount').value = data.total || '';
                        updateSplitTotal();
                        await showAlert(`「${data.place}」の情報をフォームに入力しました。`);
                    };
                    resultsDiv.appendChild(card);
                });
                usageCount++;
                localStorage.setItem(`ocrUsage_${today}`, usageCount);
                statusDiv.textContent = `${resultsArray.length}件のレシートを検出しました。`;

            } catch (err) {
                // 上記のtry-catchブロックで捕捉されなかった予期せぬエラー
                console.error("OCR処理中に予期せぬエラーが発生しました:", err);
                await showAlert('処理中に予期せぬエラーが発生しました。開発者コンソールを確認してください。', 'エラー');
            } finally {
                processBtn.disabled = false;
                processBtn.textContent = '選択したレシートを読み取る';
                uploader.value = '';
            }
        }
        
        function handleAuthClick(isSilent = false) {
            tokenClient.callback = async (resp) => {
                if (resp.error !== undefined) { if(isSilent) return; throw (resp); }
                localStorage.setItem('google_auth_loggedin', 'true');
                document.getElementById('signout_button').style.display = 'block';
                document.getElementById('authorize_button').style.display = 'none';
                document.getElementById('auth-status').textContent = 'ログイン済み';
                document.getElementById('backup_button').disabled = false;
                document.getElementById('restore_button').disabled = false;
                await findOrCreateBackupFile();
            };
            if (gapi.client.getToken() === null) {
                tokenClient.requestAccessToken({ prompt: isSilent ? '' : 'consent' });
            }
        }

        function handleSignoutClick() {
            const token = gapi.client.getToken();
            if (token !== null) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
                localStorage.removeItem('google_auth_loggedin');
                document.getElementById('authorize_button').style.display = 'block';
                document.getElementById('signout_button').style.display = 'none';
                document.getElementById('auth-status').textContent = '未ログイン';
                document.getElementById('backup_button').disabled = true;
                document.getElementById('restore_button').disabled = true;
                backupFileId = null;
            }
        }

        async function findOrCreateBackupFile() { /* 実装は省略 */ }
        async function backupToDrive() { /* 実装は省略 */ }
        async function restoreFromDrive() { /* 実装は省略 */ }
        
        function renderBalanceGraph() {
            const area = document.getElementById('balanceGraphArea');
            // Check if a chart already exists on the canvas and destroy it
            const existingChart = Chart.getChart("balanceTrendChart");
            if (existingChart) {
                existingChart.destroy();
            }
            area.innerHTML = '<canvas id="balanceTrendChart" style="max-width:100%;"></canvas>';
            const ctx = document.getElementById('balanceTrendChart').getContext('2d');
            const [year, month] = currentMonth.split('-').map(Number);
            const daysInMonth = new Date(year, month, 0).getDate();

            let balanceTrend = []; // Moved this line to the top of the function.

            // 日ごとの支出・収入集計
            let dailyChange = Array(daysInMonth).fill(0);
            transactions.filter(t => t.date && t.date.startsWith(currentMonth)).forEach(t => {
                const day = new Date(t.date).getDate() - 1;
                dailyChange[day] += (t.type === 'income' ? t.amount : -t.amount);
            });

            // 残高推移計算 (修正: 初日の残高から計算を開始)
            let startingBalanceForMonth = accountBalance;
            // 当月より前の取引の差額を計算
            transactions.filter(t => t.date && t.date < `${currentMonth}-01`).forEach(t => {
                startingBalanceForMonth += (t.type === 'income' ? t.amount : -t.amount);
            });

            let currentDayBalance = startingBalanceForMonth;
            for (let i = 0; i < daysInMonth; i++) {
                currentDayBalance += dailyChange[i];
                balanceTrend.push(currentDayBalance);
            }

            // Y軸の最小値と最大値を計算
            let minBalance;
            let maxBalance; 

            if (balanceTrend.length > 0) {
                minBalance = Math.min(...balanceTrend, startingBalanceForMonth);
                maxBalance = Math.max(...balanceTrend, startingBalanceForMonth);
            } else {
                // balanceTrendが空の場合の処理を明確にする
                minBalance = startingBalanceForMonth;
                maxBalance = startingBalanceForMonth;
            }

            let yAxisMin;
            const dataRange = maxBalance - minBalance;

            if (dataRange === 0) { // 全ての残高が同じ場合
                if (minBalance === 0) {
                    yAxisMin = -1000; // 0の場合は下に少し余白を持たせる
                } else if (minBalance > 0) {
                    yAxisMin = minBalance * 0.5; // 正の値の場合はその半分を最小値に
                } else { // minBalance < 0
                    yAxisMin = minBalance * 1.5; // 負の値の場合はさらに下に余白を
                }
            } else {
                // データ範囲の10%をバッファとして最小値から引く
                const buffer = dataRange * 0.1; 
                yAxisMin = minBalance - buffer;
            }

            // minBalanceが正の値の場合、yAxisMinが0を下回らないようにする
            if (minBalance >= 0) {
                yAxisMin = Math.max(0, yAxisMin);
            }

            // グラフ描画
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array.from({ length: daysInMonth }, (_, i) => `${i + 1}日`),
                    datasets: [{
                        label: '口座残高推移',
                        data: balanceTrend,
                        borderColor: 'rgb(46,125,50)', // Added borderColor
                        backgroundColor: 'rgba(46,125,50,0.1)',
                        fill: true,
                        tension: 0.2
                    }]
                },
                options: {
                    responsive: true,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: {
                            beginAtZero: false,
                            min: yAxisMin, // Y軸の最小値を設定
                            title: { display: true, text: '残高(円)' }
                        }
                    }
                },
            });
        }

        // 場所別支出グラフのレンダリング
        function renderSpendingByPlaceGraph() {
            const area = document.getElementById('spendingByPlaceGraphArea');
            // 既存のチャートがあれば破棄
            if (spendingByPlaceChart) {
                spendingByPlaceChart.destroy();
            }
            area.innerHTML = ''; // エリアをクリア

            // 今月の支出データを場所ごとに集計
            const spendingByPlace = transactions
                .filter(t => t.date && t.date.startsWith(currentMonth) && t.type === 'expense')
                .reduce((acc, t) => {
                    acc[t.place] = (acc[t.place] || 0) + t.amount;
                    return acc;
                }, {});

            // 集計結果を配列に変換し、金額で降順ソート
            let sortedPlaces = Object.keys(spendingByPlace).map(place => ({
                place: place,
                amount: spendingByPlace[place]
            })).sort((a, b) => b.amount - a.amount);

            // 表示項目数でフィルタリング
            const limit = parseInt(document.getElementById('spendingPlaceLimit').value) || 10;
            sortedPlaces = sortedPlaces.slice(0, limit);

            const labels = sortedPlaces.map(item => item.place);
            const data = sortedPlaces.map(item => item.amount);

            // データがない場合はメッセージを表示
            if (labels.length === 0) {
                area.innerHTML = '<p style="text-align:center; color:#666;">今月の場所別支出データはありません。</p>';
                return;
            }

            // スクロール可能なコンテナを作成
            const scrollContainer = document.createElement('div');
            scrollContainer.className = 'scroll-graph-container';
            area.appendChild(scrollContainer);

            // Canvas要素を作成
            const canvas = document.createElement('canvas');
            canvas.id = 'spendingByPlaceChart';
            
            // データ量に応じてCanvasの幅を動的に設定
            // 1項目あたり150pxの幅を確保 (バーの幅 + パディング + ラベルスペース)
            const requiredWidth = labels.length * 150; 
            
            // Canvasの描画バッファサイズを設定
            // 親コンテナの現在の表示幅と、グラフが必要とする最小幅の大きい方を使用
            canvas.width = Math.max(area.offsetWidth, requiredWidth); 
            canvas.height = 300; // 描画バッファの高さは固定

            // Canvasの表示スタイルを設定
            canvas.style.display = 'block';
            // ここを修正：canvas.width属性で設定した描画幅をそのままCSSのwidthに設定する
            canvas.style.width = `${canvas.width}px`; 
            canvas.style.height = '300px'; 

            scrollContainer.appendChild(canvas);
            const ctx = canvas.getContext('2d');


            // グラフ描画
            spendingByPlaceChart = new Chart(ctx, {
                type: 'bar', // 棒グラフを使用
                data: {
                    labels: labels,
                    datasets: [{
                        label: '支出額',
                        data: data,
                        backgroundColor: 'rgba(75, 192, 192, 0.6)', // 棒の色
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: false, // Chart.jsがCanvasのCSS幅ではなく、Canvas要素のwidth/height属性を使用するようにする
                    maintainAspectRatio: false, // アスペクト比を維持しない
                    plugins: {
                        legend: {
                            display: false // 凡例は非表示
                        },
                        title: {
                            display: true,
                            text: '場所別支出 (上位' + limit + '件)' // グラフタイトルに表示項目数を追加
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true, // Y軸は0から開始
                            title: {
                                display: true,
                                text: '金額 (円)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: '場所'
                            },
                            // ラベルが重なるのを防ぐために回転させる
                            ticks: {
                                autoSkip: false,
                                maxRotation: 90,
                                minRotation: 90,
                                font: {
                                    size: 10 // ラベルのフォントサイズを小さくする
                                }
                            }
                        }
                    }
                }
            });
        }
        
        async function checkVariableExpensesIfNeeded() {
            const today = new Date();
            const [year, month] = currentMonth.split('-').map(Number);
            // Check if the current month is the month being viewed in the selector
            // And if today's date matches the check day
            if (today.getFullYear() === year && today.getMonth() + 1 === month && today.getDate() === variableExpenseCheckDay) {
                // Prevent showing the alert multiple times in the same day
                const lastAlertDate = localStorage.getItem('lastVariableExpenseAlert');
                if (lastAlertDate !== today.toISOString().slice(0, 10)) {
                    await showAlert(`今月の変動支出は${variableExpenseDueDay}日に発生します。`);
                    localStorage.setItem('lastVariableExpenseAlert', today.toISOString().slice(0, 10));
                }
            }
        }

        /**
         * 指定された月の固定支出を生成します。
         * @param {string} month - YYYY-MM形式の月。
         */
        function addFixedExpensesForMonth(month) {
            genres.filter(g => g.type === 'fixed').forEach(g => {
                const budget = budgetsByMonth[month]?.[g.name];
                const dueDay = g.dueDay || 1; // 固定費はジャンル指定がなければ1日
                if (budget) {
                    const formattedDueDay = String(dueDay).padStart(2, '0');
                    const alreadyExists = transactions.some(t => t.date === `${month}-${formattedDueDay}` && t.genre === g.name && t.memo === '定期支出（自動）');
                    if (!alreadyExists) {
                        transactions.push({
                            date: `${month}-${formattedDueDay}`,
                            place: g.name,
                            type: 'expense',
                            genre: g.name,
                            amount: budget,
                            memo: '定期支出（自動）',
                            tags: '定期',
                            timestamp: generateUniqueId()
                        });
                    }
                }
            });
            saveData();
        }

        /**
         * 指定された月の変動支出を生成します。
         * @param {string} month - YYYY-MM形式の月。
         */
        function addVariableExpensesForMonth(month) {
            genres.filter(g => g.type === 'variable').forEach(g => {
                const budget = budgetsByMonth[month]?.[g.name];
                const dueDay = g.dueDay || variableExpenseDueDay; // ジャンルごとの発生日を優先、なければ全体設定
                if (budget) {
                    const formattedDueDay = String(dueDay).padStart(2, '0');
                    const alreadyExists = transactions.some(t => t.date === `${month}-${formattedDueDay}` && t.genre === g.name && t.memo === '変動支出（自動）');
                    if (!alreadyExists) {
                        transactions.push({
                            date: `${month}-${formattedDueDay}`,
                            place: g.name,
                            type: 'expense',
                            genre: g.name,
                            amount: budget,
                            memo: '変動支出（自動）',
                            tags: '変動',
                            timestamp: generateUniqueId()
                        });
                    }
                }
            });
            saveData();
        }

        /**
         * 予算の繰越ロジックを適用します。
         * 前月の予算残高（余剰または不足）を当月の予算に反映させます。
         * @param {string} newMonth - 当月 (YYYY-MM形式)。
         */
        function applyBudgetRollover(newMonth) {
            const prevMonthDate = new Date(newMonth + '-01');
            prevMonthDate.setMonth(prevMonthDate.getMonth() - 1);
            const prevMonth = prevMonthDate.toISOString().slice(0, 7);

            // 当月の予算がまだ存在しない場合は初期化
            if (!budgetsByMonth[newMonth]) {
                budgetsByMonth[newMonth] = {};
            }

            rolloverGenres.forEach(genreName => {
                const prevMonthBudget = budgetsByMonth[prevMonth]?.[genreName] || 0;
                const prevMonthSpent = transactions
                    .filter(t => t.date && t.date.startsWith(prevMonth) && t.genre === genreName && t.type === 'expense')
                    .reduce((sum, t) => sum + t.amount, 0);
                
                const rolloverAmount = prevMonthBudget - prevMonthSpent;

                // 当月の予算に繰越額を加算
                // 当月にそのジャンルの予算が設定されていない場合は、繰越額がそのまま予算となる
                budgetsByMonth[newMonth][genreName] = (budgetsByMonth[newMonth][genreName] || 0) + rolloverAmount;
            });
            saveData();
        }

        // --- 財務健全性スコアとアドバイスのレンダリング ---
        function renderFinancialHealthSection() {
            const scoreDisplay = document.getElementById('financialHealthScoreDisplay');
            const insightsDisplay = document.getElementById('financialHealthInsights');
            
            const { score, insights } = calculateFinancialHealthScoreAndInsights();

            scoreDisplay.textContent = `${Math.round(score)}点`;
            
            if (insights.length > 0) {
                insightsDisplay.innerHTML = insights.map(insight => `<p style="margin-bottom:0.5rem;">${insight}</p>`).join('');
            } else {
                insightsDisplay.innerHTML = '<p style="text-align:center; color:#999;">今月の財務健全性に関するデータがまだありません。</p>';
            }
        }

        /**
         * 財務健全性スコアとアドバイスを計算します。
         * @returns {{score: number, insights: string[]}} スコアとアドバイスの配列
         */
        function calculateFinancialHealthScoreAndInsights() {
            let score = 100; // 初期スコア
            const insights = [];
            const currentMonthExpenses = transactions.filter(t => t.date && t.date.startsWith(currentMonth) && t.type === 'expense');
            const currentMonthIncome = transactions.filter(t => t.date && t.date.startsWith(currentMonth) && t.type === 'income');

            const monthlyBudget = budgetsByMonth[currentMonth] || {};

            // 1. 予算達成度 (Budget Adherence)
            const currentMonthExpensesByGenre = currentMonthExpenses.reduce((acc, t) => {
                acc[t.genre] = (acc[t.genre] || 0) + t.amount;
                return acc;
            }, {});

            let totalBudget = 0;
            let totalSpent = 0;

            Object.keys(monthlyBudget).forEach(genre => {
                const budget = monthlyBudget[genre];
                const spent = currentMonthExpensesByGenre[genre] || 0;
                totalBudget += budget;
                totalSpent += spent;

                const difference = budget - spent;
                if (difference < 0) { // 予算オーバー
                    const overagePercentage = Math.abs(difference) / budget * 100;
                    score -= Math.min(20, Math.round(overagePercentage / 5)); // 5%オーバーごとに1点減点、最大20点
                    insights.push(`⚠️ ${genre}が予算を${new Intl.NumberFormat().format(Math.abs(difference))}円オーバーしています。`);
                } else if (difference > 0 && budget > 0) { // 予算内、かつ予算が設定されている場合
                    insights.push(`✨ ${genre}で${new Intl.NumberFormat().format(difference)}円の節約に成功しています。`);
                }
            });

            // 全体予算の評価
            if (totalBudget > 0) {
                const overallDifference = totalBudget - totalSpent;
                if (overallDifference < 0) {
                    const overagePercentage = Math.abs(overallDifference) / totalBudget * 100;
                    score -= Math.min(30, Math.round(overagePercentage / 3)); // 全体予算オーバーは重く減点
                    insights.push(`🚨 今月は全体で予算を${new Intl.NumberFormat().format(Math.abs(overallDifference))}円オーバーしています。`);
                } else if (overallDifference > 0) {
                    insights.push(`✅ 今月は全体で${new Intl.NumberFormat().format(overallDifference)}円の節約ができています！`);
                }
            } else {
                insights.push('💡 今月の予算が設定されていません。予算を設定すると、より詳細な分析が可能です。');
            }


            // 2. 支出の安定性 (Spending Stability) - 過去3ヶ月の平均と比較
            const threeMonthsAgo = new Date(currentMonth + '-01');
            threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
            const recentMonths = [];
            for (let i = 0; i < 3; i++) {
                const d = new Date(threeMonthsAgo);
                d.setMonth(d.getMonth() + i);
                recentMonths.push(d.toISOString().slice(0, 7));
            }

            const keyCategories = genres.filter(g => g.type === '').map(g => g.name); // 通常ジャンルを対象
            const historicalSpending = {}; // { genre: { month: amount } }

            transactions.filter(t => recentMonths.includes(t.date.slice(0, 7)) && t.type === 'expense').forEach(t => {
                if (!historicalSpending[t.genre]) historicalSpending[t.genre] = {};
                const monthKey = t.date.slice(0, 7);
                historicalSpending[t.genre][monthKey] = (historicalSpending[t.genre][monthKey] || 0) + t.amount;
            });

            keyCategories.forEach(genre => {
                const currentSpending = currentMonthExpensesByGenre[genre] || 0;
                const pastSpendings = recentMonths.map(month => historicalSpending[genre]?.[month] || 0);
                const pastAverage = pastSpendings.reduce((sum, val) => sum + val, 0) / pastSpendings.length;

                if (pastAverage > 0 && currentSpending > pastAverage * 1.2) { // 20%以上増加
                    const increasePercentage = ((currentSpending - pastAverage) / pastAverage * 100).toFixed(0);
                    score -= Math.min(15, Math.round(increasePercentage / 10)); // 10%増加ごとに1点減点、最大15点
                    insights.push(`📈 ${genre}の支出が過去3ヶ月平均より${increasePercentage}%増加しています。`);
                } else if (pastAverage > 0 && currentSpending < pastAverage * 0.8) { // 20%以上減少
                    const decreasePercentage = ((pastAverage - currentSpending) / pastAverage * 100).toFixed(0);
                    insights.push(`📉 ${genre}の支出が過去3ヶ月平均より${decreasePercentage}%減少しています。素晴らしい！`);
                }
            });

            // 3. 収入と支出のバランス (Income vs Expense)
            const totalCurrentMonthIncome = currentMonthIncome.reduce((sum, t) => sum + t.amount, 0);
            const totalCurrentMonthExpense = currentMonthExpenses.reduce((sum, t) => sum + t.amount, 0);

            if (totalCurrentMonthIncome > 0) {
                const savingRate = (totalCurrentMonthIncome - totalCurrentMonthExpense) / totalCurrentMonthIncome * 100;
                if (savingRate < 0) {
                    score -= Math.min(20, Math.round(Math.abs(savingRate) / 2)); // 赤字は重く減点
                    insights.push(`💔 今月は${new Intl.NumberFormat().format(Math.abs(totalCurrentMonthIncome - totalCurrentMonthExpense))}円の赤字です。支出を見直しましょう。`);
                } else if (savingRate < 10) {
                    insights.push(`🤔 貯蓄率は${savingRate.toFixed(0)}%です。もう少し貯蓄を増やせるかもしれません。`);
                } else {
                    insights.push(`💰 貯蓄率は${savingRate.toFixed(0)}%と健全です！この調子で貯蓄を続けましょう。`);
                }
            } else {
                insights.push('💡 今月の収入が記録されていません。収入を記録すると、より正確な財務健全性評価が可能です。');
            }

            // スコアを0-100の範囲に収める
            score = Math.max(0, Math.min(100, score));

            // ポジティブなフィードバックが少ない場合は追加
            if (insights.length === 0 || insights.every(i => i.startsWith('⚠️') || i.startsWith('🚨') || i.startsWith('📈') || i.startsWith('💔') || i.startsWith('🤔'))) {
                insights.push('✨ 今月は全体的に良好な家計管理ができています。素晴らしい！');
            }

            return { score, insights };
        }


        // --- 定期的な取引リストのレンダリング ---
        function renderRecurringTransactionsList() {
            const listDiv = document.getElementById('recurringTransactionsList');
            listDiv.innerHTML = '';
            const recurringGenres = genres.filter(g => g.type === 'fixed' || g.type === 'variable');

            if (recurringGenres.length === 0) {
                listDiv.innerHTML = '<p style="text-align:center; color:#666;">定期的な取引が設定されていません。</p>';
                return;
            }

            let html = '<ul style="list-style:none; padding:0;">';
            recurringGenres.forEach(g => {
                const typeText = g.type === 'fixed' ? '固定' : '変動';
                const dueDay = g.dueDay || (g.type === 'fixed' ? 1 : variableExpenseDueDay); // ジャンルごとの発生日を優先、なければデフォルト
                const dueDayText = `毎月${dueDay}日` + (g.dueDay ? '' : ' (全体設定)');
                const budget = budgetsByMonth[currentMonth]?.[g.name] || 0;
                const transactionExists = transactions.some(t => 
                    t.date && t.date.startsWith(currentMonth) && 
                    t.genre === g.name && 
                    (t.memo === '定期支出（自動）' || t.memo === '変動支出（自動）')
                );
                const statusText = transactionExists ? '<span style="color:green;">✔ 生成済み</span>' : '<span style="color:orange;">未生成</span>';

                html += `
                    <li style="display:flex; justify-content:space-between; align-items:center; padding:8px 0; border-bottom:1px dashed var(--border-color-light);">
                        <div>
                            <strong>${g.name}</strong> (${typeText}) - 発生日: ${dueDayText}<br>
                            <span style="font-size:0.9rem; color:#666;">今月の予算: ${new Intl.NumberFormat().format(budget)}円</span>
                        </div>
                        <div>${statusText}</div>
                    </li>
                `;
            });
            html += '</ul>';
            listDiv.innerHTML = html;
        }

        // --- DOM読み込み後の初期化処理 ---
        document.addEventListener('DOMContentLoaded', () => {
            loadData();

            document.getElementById('homeTab').addEventListener('click', () => switchTab('home'));
            document.getElementById('settingsTab').addEventListener('click', () => switchTab('settings'));
            document.getElementById('recordForm').addEventListener('submit', handleRecordSubmit);
            document.getElementById('add-split-item-btn').addEventListener('click', () => addSplitItemRow(document.getElementById('split-items-container')));
            
            // 場所入力フィールドの変更を監視してジャンルを自動補完
            document.getElementById('place').addEventListener('input', (e) => {
                const placeInput = e.target.value.trim();
                if (placeInput && placeGenreMap[placeInput]) {
                    const genresForPlace = placeGenreMap[placeInput];
                    let bestGenre = '';
                    let maxCount = 0;
                    for (const genre in genresForPlace) {
                        if (genresForPlace[genre] > maxCount) {
                            maxCount = genresForPlace[genre];
                            bestGenre = genre;
                        }
                    }
                    if (bestGenre) {
                        // 既存の分割項目があれば、そのジャンルを更新
                        const firstSplitGenreSelect = document.querySelector('.split-genre');
                        if (firstSplitGenreSelect) {
                            firstSplitGenreSelect.value = bestGenre;
                        }
                    }
                }
            });

            document.getElementById('addGenreBtn').addEventListener('click', addGenre);
            document.getElementById('setBudgetBtn').addEventListener('click', setBudget);
            document.getElementById('copyBudgetBtn').addEventListener('click', copyLastMonthBudget);
            document.getElementById('monthSelector').addEventListener('change', e => {
                const newMonth = e.target.value;
                if (newMonth !== currentMonth) {
                    currentMonth = newMonth;
                    applyBudgetRollover(currentMonth); // 予算繰越を適用
                    addFixedExpensesForMonth(currentMonth); // 固定費を追加
                    addVariableExpensesForMonth(currentMonth); // 変動費を追加
                    renderApp();
                }
            });
            document.getElementById('exportDataBtn').addEventListener('click', exportData);
            document.getElementById('importDataButton').addEventListener('click', () => document.getElementById('importFileInput').click());
            document.getElementById('importFileInput').addEventListener('change', e => importData(e.target.files[0]));
            
            const apiKeyInput = document.getElementById('apiKeyInput');
            apiKeyInput.value = localStorage.getItem('geminiApiKey') || '';
            document.getElementById('saveApiKeyBtn').addEventListener('click', async () => {
                const key = apiKeyInput.value.trim();
                if (key) {
                    localStorage.setItem('geminiApiKey', key);
                    await showAlert('APIキーを保存しました。');
                } else {
                    await showAlert('APIキーを入力してください。');
                }
            });

            document.getElementById('process-receipts-btn').addEventListener('click', handleReceiptProcessing);
            document.getElementById('authorize_button').addEventListener('click', () => handleAuthClick(false));
            document.getElementById('signout_button').addEventListener('click', handleSignoutClick);
            document.getElementById('backup_button').addEventListener('click', backupToDrive);
            document.getElementById('restore_button').addEventListener('click', restoreFromDrive);
            
            document.getElementById('monthlyReportBtn').addEventListener('click', () => {
                const area = document.getElementById('monthlyReportArea');
                area.style.display = area.style.display === 'block' ? 'none' : 'block'; // トグル表示
                if (area.style.display === 'block') {
                   updateBudgetTable(); // レポート内容を更新
                   area.innerHTML = document.getElementById('budgetTableArea').innerHTML;
                }
            });

            document.getElementById('saveAccountBalanceBtn').addEventListener('click', async () => {
                const val = parseInt(document.getElementById('accountBalanceInput').value);
                if (!isNaN(val)) {
                    accountBalance = val;
                    saveData();
                    await showAlert('口座残高を保存しました。');
                    renderBalanceGraph();
                } else {
                    await showAlert('有効な数値を入力してください。');
                }
            });
            
            document.getElementById('saveVariableExpenseCheckDayBtn').addEventListener('click', async () => {
                const val = parseInt(document.getElementById('variableExpenseCheckDay').value);
                if (!isNaN(val) && val >= 1 && val <= 31) {
                    variableExpenseCheckDay = val;
                    saveData();
                    document.getElementById('variableExpenseStatus').textContent = `変動支出の発生日は、各ジャンルで設定された日付（未設定の場合は毎月${variableExpenseDueDay}日）です。`;
                    await showAlert('変動支出確認日を保存しました。');
                } else {
                    await showAlert('1～31の範囲で入力してください。');
                }
            });

            document.getElementById('saveVariableExpenseDueDayBtn').addEventListener('click', async () => {
                const val = parseInt(document.getElementById('variableExpenseDueDay').value);
                if (!isNaN(val) && val >= 1 && val <= 31) {
                    variableExpenseDueDay = val;
                    localStorage.setItem('variableExpenseDueDay', val);
                    document.getElementById('variableExpenseStatus').textContent = `変動支出の発生日は、各ジャンルで設定された日付（未設定の場合は毎月${variableExpenseDueDay}日）です。`;
                    await showAlert('変動支出の発生日を保存しました。');
                } else {
                    await showAlert('1～31の範囲で入力してください。');
                }
            });

            // 「今月の定期取引を生成」ボタンのイベントリスナーを追加
            document.getElementById('generateRecurringTransactionsBtn').addEventListener('click', async () => {
                const confirmed = await showConfirm(`今月（${currentMonth}）の定期取引を生成しますか？`);
                if (confirmed) {
                    addFixedExpensesForMonth(currentMonth);
                    addVariableExpensesForMonth(currentMonth);
                    renderApp();
                    await showAlert('今月の定期取引を生成しました。');
                }
            });

            // 並べ替えコントロールのイベントリスナー
            document.getElementById('budgetSortBy').addEventListener('change', (e) => {
                budgetSortColumn = e.target.value;
                renderApp();
            });

            document.getElementById('budgetSortDirection').addEventListener('click', (e) => {
                budgetSortDirection = budgetSortDirection === 'asc' ? 'desc' : 'asc';
                e.target.textContent = budgetSortDirection === 'asc' ? '▲' : '▼';
                renderApp();
            });

            // 場所別支出グラフの表示項目数更新ボタンのイベントリスナー
            document.getElementById('updateSpendingPlaceGraphBtn').addEventListener('click', () => {
                const newLimit = parseInt(document.getElementById('spendingPlaceLimit').value);
                if (!isNaN(newLimit) && newLimit > 0) {
                    spendingPlaceLimit = newLimit;
                    renderSpendingByPlaceGraph(); // グラフを再レンダリング
                } else {
                    showAlert('有効な表示項目数を入力してください (1以上の数値)。');
                }
            });


            const container = document.getElementById('split-items-container');
            addSplitItemRow(container);
            updateSplitTotal();
            document.getElementById('date').valueAsDate = new Date();
            
            // 初期読み込み時に固定費と変動費をチェック
            addFixedExpensesForMonth(currentMonth);
            addVariableExpensesForMonth(currentMonth);
            switchTab('home');
            renderApp();
        });

        function editTransaction(timestamp) {
            const transaction = transactions.find(t => t.timestamp === timestamp);
            if (!transaction) return;

            // モーダルを表示
            document.getElementById('editTransactionModal').style.display = 'block';
            document.getElementById('modalOverlay').style.display = 'block';

            // フォームにデータをセット
            document.getElementById('editDate').value = transaction.date || '';
            document.getElementById('editPlace').value = transaction.place || '';
            document.getElementById('editAmount').value = transaction.amount || 0;
            document.getElementById('editMemo').value = transaction.memo || '';
            document.getElementById('editTags').value = transaction.tags || '';

            // ジャンルセレクトボックスを更新
            const genreSelect = document.getElementById('editGenre');
            genreSelect.innerHTML = '';
            genres.forEach(g => {
                const option = document.createElement('option');
                option.value = g.name;
                option.textContent = g.name;
                if (g.name === transaction.genre) option.selected = true;
                genreSelect.appendChild(option);
            });

            // 保存ボタンの動作を設定
            const form = document.getElementById('editTransactionForm');
            form.onsubmit = (e) => {
                e.preventDefault();
                saveEditedTransaction(timestamp);
            };

            // キャンセルボタンの動作を設定
            document.getElementById('cancelEditBtn').onclick = () => {
                document.getElementById('editTransactionModal').style.display = 'none';
                document.getElementById('modalOverlay').style.display = 'none';
            };
        }

        async function saveEditedTransaction(timestamp) {
            const transaction = transactions.find(t => t.timestamp === timestamp);
            if (!transaction) return;

            // フォームのデータを取得
            transaction.date = document.getElementById('editDate').value;
            transaction.place = document.getElementById('editPlace').value;
            transaction.amount = parseInt(document.getElementById('editAmount').value);
            transaction.memo = document.getElementById('editMemo').value; // Added memo
            transaction.tags = document.getElementById('editTags').value; // Added tags
            transaction.genre = document.getElementById('editGenre').value; // Added genre

            // データを保存してUIを更新
            saveData();
            renderApp();

            // モーダルを閉じる
            document.getElementById('editTransactionModal').style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';

            await showAlert('履歴を更新しました。');
        }

        function openEditGenreModal(index) {
            const genre = genres[index];
            if (!genre) return;

            // モーダルを表示
            document.getElementById('editGenreModal').style.display = 'block';
            document.getElementById('editGenreOverlay').style.display = 'block';

            // フォームにデータをセット
            document.getElementById('editGenreName').value = genre.name || '';
            document.getElementById('editGenreType').value = genre.type || '';
            document.getElementById('editGenreDueDay').value = genre.dueDay || '';

            // 保存ボタンの動作を設定
            const form = document.getElementById('editGenreForm');
            form.onsubmit = (e) => {
                e.preventDefault();
                saveEditedGenre(index);
            };

            // キャンセルボタンの動作を設定
            document.getElementById('cancelEditGenreBtn').onclick = () => {
                document.getElementById('editGenreModal').style.display = 'none';
                document.getElementById('editGenreOverlay').style.display = 'none';
            };
        }

        async function saveEditedGenre(index) {
            const genre = genres[index];
            if (!genre) return;

            const oldName = genre.name;
            const newName = document.getElementById('editGenreName').value.trim();
            const newType = document.getElementById('editGenreType').value;
            const newDueDay = parseInt(document.getElementById('editGenreDueDay').value) || null;

            // データを更新
            genre.name = newName;
            genre.type = newType;
            genre.dueDay = newDueDay;

            // 関連データを更新
            transactions.forEach(t => {
                if (t.genre === oldName) t.genre = newName;
            });

            Object.keys(budgetsByMonth).forEach(month => {
                if (budgetsByMonth[month][oldName]) {
                    budgetsByMonth[month][newName] = budgetsByMonth[month][oldName];
                    delete budgetsByMonth[month][oldName];
                }
            });

            // データを保存してUIを更新
            saveData();
            renderApp();

            // モーダルを閉じる
            document.getElementById('editGenreModal').style.display = 'none';
            document.getElementById('editGenreOverlay').style.display = 'none';

            await showAlert('ジャンルを更新しました。');
        }
    </script>
</body>
</html>
